---
// 遅延読み込みコンポーネント
export interface Props {
    threshold?: number;
    rootMargin?: string;
    className?: string;
    fallback?: string;
}

const { 
    threshold = 0.1, 
    rootMargin = '50px 0px', 
    className = '',
    fallback = 'Loading...'
} = Astro.props;
---

<div 
    class={`lazy-load-container ${className}`}
    data-threshold={threshold}
    data-root-margin={rootMargin}
>
    <div class="lazy-content" style="display: none;">
        <slot />
    </div>
    <div class="lazy-fallback">
        <div class="loading-spinner"></div>
        <span>{fallback}</span>
    </div>
</div>

<style>
    .lazy-load-container {
        min-height: 200px;
        position: relative;
    }

    .lazy-fallback {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 200px;
        color: #94a3b8;
        font-size: 14px;
    }

    .loading-spinner {
        width: 32px;
        height: 32px;
        border: 2px solid rgba(59, 130, 246, 0.2);
        border-top: 2px solid #3b82f6;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 12px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .lazy-content.loaded {
        display: block !important;
    }

    .lazy-fallback.hidden {
        display: none !important;
    }

    /* パフォーマンス向上のためのCSS */
    .lazy-load-container {
        contain: layout style paint;
        content-visibility: auto;
    }
</style>

<script>
    // Intersection Observer for lazy loading
    const observer = new IntersectionObserver(
        (entries) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    const container = entry.target;
                    const content = container.querySelector('.lazy-content');
                    const fallback = container.querySelector('.lazy-fallback');

                    // コンテンツを表示
                    if (content && fallback) {
                        content.style.display = 'block';
                        content.classList.add('loaded');
                        fallback.classList.add('hidden');
                        
                        // アニメーション効果
                        content.style.opacity = '0';
                        content.style.transform = 'translateY(20px)';
                        
                        setTimeout(() => {
                            content.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                            content.style.opacity = '1';
                            content.style.transform = 'translateY(0)';
                        }, 50);
                    }

                    // 監視を停止
                    observer.unobserve(container);
                }
            });
        },
        {
            threshold: 0.1,
            rootMargin: '50px 0px'
        }
    );

    // ページ読み込み時に要素を監視開始
    document.addEventListener('DOMContentLoaded', () => {
        const lazyContainers = document.querySelectorAll('.lazy-load-container');
        
        lazyContainers.forEach((container) => {
            // カスタム設定を読み取り
            const threshold = parseFloat(container.dataset.threshold) || 0.1;
            const rootMargin = container.dataset.rootMargin || '50px 0px';
            
            // 個別のオブザーバーを作成（カスタム設定用）
            const customObserver = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            const container = entry.target;
                            const content = container.querySelector('.lazy-content');
                            const fallback = container.querySelector('.lazy-fallback');

                            if (content && fallback) {
                                content.style.display = 'block';
                                content.classList.add('loaded');
                                fallback.classList.add('hidden');
                                
                                // スムーズなフェードイン
                                content.style.opacity = '0';
                                content.style.transform = 'translateY(20px)';
                                
                                requestAnimationFrame(() => {
                                    content.style.transition = 'opacity 0.4s ease, transform 0.4s ease';
                                    content.style.opacity = '1';
                                    content.style.transform = 'translateY(0)';
                                });
                            }

                            customObserver.unobserve(container);
                        }
                    });
                },
                { threshold, rootMargin }
            );
            
            customObserver.observe(container);
        });
    });

    // パフォーマンス監視
    if ('PerformanceObserver' in window) {
        try {
            const perfObserver = new PerformanceObserver((list) => {
                list.getEntries().forEach((entry) => {
                    if (entry.entryType === 'largest-contentful-paint') {
                        console.log('LCP:', entry.startTime);
                    }
                });
            });
            
            perfObserver.observe({ entryTypes: ['largest-contentful-paint'] });
        } catch (error) {
            // パフォーマンス監視エラーは無視
        }
    }
</script>